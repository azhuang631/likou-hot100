#### 1.哈希

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

 **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```java
// 使用map储存（nums[i], i），遍历时求target - nums[i]
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i ++ ) {
            int ans = target - nums[i];
            if(map.containsKey(ans)) {
                return new int[]{map.get(ans), i};
            }
            map.put(nums[i], i);
        }
        return new int[2];
    }
}
```

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母

```java
// 使用map储存（aet, ["ate","eat","tea"]），key为string转换为char[]后排序
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // key储存排序后String，[aet, ["ate","eat","tea"]]
        Map<String, List<String>> map = new HashMap<>();
        for(String str: strs) {
            char[] c = str.toCharArray();
            Arrays.sort(c);
            String sortStr = new String(c);
            List<String> list;
            if(map.containsKey(sortStr)) {
                list = map.get(sortStr);
            }
            else {
                list = new ArrayList<>();
            }
            list.add(str);
            map.put(sortStr, list);
        }
        List<List<String>> ans = new ArrayList<>();
        for(String s : map.keySet()) {
            ans.add(map.get(s));
        }
        return ans;
    }
}

// 使用map储存（a1e1t1, ["ate","eat","tea"]），key为string中字母+数量
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // key储存字母+数量，[a1e1t1, ["ate","eat","tea"]]
        Map<String, List<String>> map = new HashMap<>();
        for(String str : strs) {
            char[] c = str.toCharArray();
            int[] nums = new int[26];
            for(int i = 0; i < c.length; i ++ ) {
                nums[c[i] - 'a'] ++ ;
            }
            StringBuffer sb = new StringBuffer();
            for(int i = 0; i < 26; i ++ ) {
                if(nums[i] != 0) {
                    sb.append((char)('a' + i)).append(nums[i]);
                }
            }
            String s = sb.toString();
            List<String> list = map.getOrDefault(s, new ArrayList<>());
            list.add(str);
            map.put(s, list);
        }
        return new ArrayList<>(map.values());
    }
}
```

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

```java
// map储存（数字，该数字序列的长度）,根据map判断前后数字得出当前num的序列，并更新该num序列的前端与后端
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        Map<Integer, Integer> map = new HashMap<>();
        int max = -1;
        for(int num : nums) {
            if(!map.containsKey(num)) {
                int last = map.getOrDefault(num - 1, 0);// 上一个数
                int next = map.getOrDefault(num + 1, 0);// 下一个数
                int count = last + 1 + next;
                max = Math.max(count, max);
                map.put(num, count);
                if(map.containsKey(num - last)) map.put(num - last, count);// 更新序列的前端
                if(map.containsKey(num + next)) map.put(num + next, count);// 更新序列的后端
            // System.out.println(num + " " + map.get(num));
            }
        }
        return max;
    }
}

// 官方：使用set储存数组元素，找到序列的第一个元素遍历求len
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int num: nums) {
            set.add(num);
        }
        int max = 0;
        for(int num: nums) {
            if(!set.contains(num - 1)) {
                int len = 1;
                while(set.contains(num + 1)) {
                    num ++ ;
                    len ++ ;
                }
                max = Math.max(max, len);
            }
        }
        return max;
    }
}
```

